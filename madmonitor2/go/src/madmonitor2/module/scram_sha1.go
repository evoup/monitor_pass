/*
 * This file is part of madmonitor2.
 * Copyright (c) 2018. Author: yinjia evoex123@gmail.com
 *
 * This program is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.  This program is distributed in the hope that it
 * will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser
 * General Public License for more details.  You should have received a copy
 * of the GNU Lesser General Public License along with this program.  If not,
 * see <http://www.gnu.org/licenses/>.
 */

package module

import (
	"math/rand"
	"fmt"
	"bytes"
	"regexp"
)

var cHeader = "evps"

func RandStringBytesRmndr(n int) string {
	letterBytes := "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	b := make([]byte, n)
	for i := range b {
		b[i] = letterBytes[rand.Int63()%int64(len(letterBytes))]
	}
	return string(b)
}

// Client nonce: This is a value that is randomly generated by the client,
// ideally using a cryptographic random generator.
func makeClientNonce() string {
	return RandStringBytesRmndr(10)
}

func clientFirstMessageBare(cName, cNonce []byte) (out []byte) {
	out = []byte("n=")
	out = append(out, cName...)
	out = append(out, ",r="...)
	out = append(out, cNonce...)
	return
}

func clientFirstMessage(cName, cNonce []byte) (out []byte) {
	out = []byte("n,,")
	out = append(out, clientFirstMessageBare(cName, cNonce)...)
	return
}

func getAttribute(message []byte, attribute byte) []byte {
	attributes := bytes.Split(message, []byte{','})

	for _, a := range attributes {
		if len(a) > 0 && a[0] == attribute {
			return a[2:]
		}
	}
	return nil
}

func scramSha1FirstMessage(cname string) ([]byte, []byte) {
	fmt.Println("scram sha-1 login")
	//cName := []byte("clientName")
	cName := []byte(cname)
	cNonce := []byte(makeClientNonce())
	cFirstMessage := clientFirstMessage(cName, cNonce)
	fmt.Printf("C: %s\n", cFirstMessage)
	cNonce = getAttribute(cFirstMessage, byte('r'))
	return cFirstMessage, cNonce
}

func scramSha1FinalMessage(serverFisrtMessage string, cnonce string) []byte {
	// server first message e.g.:
	// r=client nonce+server nonce s=server salt i=iterator
	// r=oJnNPGsiuz152d4ba7-d324-4228-8a63-78b352851853,s=b174075f-7512-421c-92ab-81cc1fcf9585,i=4096
	r := regexp.MustCompile(`r=([^,]*),s=([^,]*),i=(.*)$`)
	submatch := r.FindAllStringSubmatch(serverFisrtMessage, -1)
	if submatch != nil {
		fmt.Print(submatch)
		nonce := submatch[0][1]
		salt := submatch[0][2]
		iter := submatch[0][3]
		fmt.Println(nonce)
		fmt.Println(salt)
		fmt.Println(iter)
		// 检查nonce是不是以cnonce和snonce连接而成
		cnonceLen := len(cnonce)
		remoteCnonce := nonce[0:cnonceLen]
		if remoteCnonce != cnonce {
			// 认证失败
			return []byte("")
		}
		snonce := nonce[0+cnonceLen:]
		fmt.Println(snonce)
	}
	fmt.Println(serverFisrtMessage)
	s := cHeader
	fmt.Println(s)
	return []byte("")
}
